---
version: '3'

vars:
  GITHUB_ISSUES: true
  GITHUB_WIKI: false
  GITLAB_WIKI: false

env:
  CLICOLOR:
    sh: if [[ "${container:=}" == 'docker' ]]; then echo "0"; else echo "1"; fi

tasks:
  convert:folder:submodule:
    deps:
      - github:update
      - gitlab:update
    vars:
      BASENAME:
        sh: basename "$PWD"
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json
    cmds:
      - git init
      - git remote add origin "{{.GITLAB_REPO}}"
      - git add --all
      - git commit -m "refactor(convert-dir-to-submodule) Adding folder/project to its own git repository."
      - git push origin master
      - |
        cd ..
        rm -rf {{.BASENAME}}
        git add {{.BASENAME}}
        git commit -m "refactor(convert-dir-to-submodule) Removing folder which will now be a submodule."
        git submodule add -b master "{{.GITLAB_REPO}}" {{.BASENAME}}
        git add {{.BASENAME}}
        git commit -m "refactor(convert-dir-to-submodule) Adding new submodule which was previously a directory."
        git push -u origin HEAD
      - true success 'Converted the `{{.BASENAME}}` directory to a submodule'
    preconditions:
      - sh: '[[ ! $(git rev-parse --git-dir) =~ ".git/modules" ]]'
        msg: Cannot convert the directory to a submodule - the directory already appears to be a submodule.

  github:create:
    deps:
      - :install:software:gh
      - :install:software:jq
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      HOMEPAGE:
        sh: jq -r '.homepage' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo '--private'; else echo '--public'; fi
    env:
      TMP:
        sh: mktemp
    run: once
    cmds:
      - cmd: >
          if [ ! -z "$GITHUB_TOKEN" ] && test -e .git && ! gh repo view {{.GITHUB_ORG}}/{{.GITHUB_SLUG}} 2&>1 /dev/null; then
            gh repo create "{{.GITHUB_SLUG}}" --enable-wiki={{.GITHUB_WIKI}} -y --description "ðŸ”¥ðŸ‘‰ {{.DESCRIPTION}} ðŸš€" \
              --homepage "{{.HOMEPAGE}}" {{.PROJECT_TYPE}} 2&>1 /dev/null
          else
            true warn 'The `GITHUB_TOKEN` environment variable is not set so the GitLab repository cannot be updated via the API.'
          fi
        ignore_error: true
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.GITHUB_SLUG}}" != "null" ]'
        msg: The `.name` in `package.json` must be set.
      - sh: '[ "{{.HOMEPAGE}}" != "null" ]'
        msg: The `.homepage` in `package.json` must be set.

  github:update:
    deps:
      - github:update:meta
      - github:variables

  github:update:meta:
    deps:
      - :install:software:gh
      - :install:software:jq
      - github:create
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      HOMEPAGE:
        sh: jq -r '.homepage' package.json
      PRIVATE:
        sh: jq -r '.private' package.json | sed 's/null/false/'
    env:
      OPTIONAL_TAGS:
        sh: jq '.keywords' .config/common-keywords.json
      TOPICS:
        sh: jq '.keywords' package.json | sed 's/null/[]/'
      TOPICS_LENGTH:
        sh: jq -r '.keywords | length' package.json
    cmds:
      - >
        if [ ! -z "$GITHUB_TOKEN" ]; then
          gh api -X PATCH repos/{owner}/{repo} -f description="ðŸ”¥ðŸ‘‰ {{.DESCRIPTION}} ðŸš€" -f homepage="{{.HOMEPAGE}}" \
            -f has_issues={{.GITHUB_ISSUES}} -f has_wiki={{.GITHUB_WIKI}} -f private="{{.PRIVATE}}" --silent
          RESULT="$TOPICS"
          if [ "$TOPICS_LENGTH" -gt 20 ]; then
            function updateList() {
              REMOVE_KEY="$(jq -n --argjson optional "$OPTIONAL_TAGS" '$optional['"$1"']')"
              RESULT="$(jq -n --argjson remove "$REMOVE_KEY" --argjson jq "$RESULT" '$jq | del(.[] | select(. == $remove))')"
            }
            LOOP_COUNT="$((TOPICS_LENGTH-20))"
            for i in $(seq "$LOOP_COUNT"); do
              updateList "$i"
            done
          fi
          MINIMIZED_TOPICS="$(jq -n --argjson tags "$RESULT" '$tags | .[]' | xargs | sed 's/ /","/g' | sed 's/^/"/' | sed 's/$/"/')"
          if [[ "$MINIMIZED_TOPICS" != '""' ]]; then
            curl -s -X PUT -H "Accept: application/vnd.github.mercy-preview+json" -u "{{.GITHUB_ORG}}:$GITHUB_TOKEN" \
              'https://api.github.com/repos/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}/topics' -d '{"names":['"$MINIMIZED_TOPICS"']}' > /dev/null
          fi
        else
          true warn 'The `GITHUB_TOKEN` environment variable is not set so the GitHub repository cannot be updated via the API.'
        fi
    sources:
      - .config/common-keywords.json
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.HOMEPAGE}}" != "null" ]'
        msg: The `.homepage` in `package.json` must be set.

  github:variables:
    deps:
      - :install:software:gh
      - github:create
    cmds:
      - |
        if [ ! -z "$GITHUB_TOKEN" ] && [ ! -z "$ANSIBLE_GALAXY_TOKEN" ] && [ '{{.REPOSITORY_TYPE}}' == 'ansible' ]; then
          gh secret set ANSIBLE_GALAXY_TOKEN -b "$ANSIBLE_GALAXY_TOKEN"
        fi
    status:
      - '[ -z "$GITHUB_TOKEN" ] || [ -z "$ANSIBLE_GALAXY_TOKEN" ] || [ "{{.REPOSITORY_TYPE}}" != "ansible" ]'

  gitlab:create:
    deps:
      - :install:software:glab
      - :install:software:jq
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITLAB_GROUP:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/https:\/\/gitlab.com\///' | sed 's!/[^/]*$!!'
      GITLAB_PATH:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/https:\/\/gitlab.com\///'
      NAME:
        sh: jq -r '.blueprint.name' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo '--private'; else echo '--public'; fi
      TMP:
        sh: mktemp
    env:
      KEYWORDS:
        sh: jq -r '.keywords | tostring' package.json | sed 's/\[//' | sed 's/\]//'
    run: once
    cmds:
      - cmd: >
          if [ ! -z "$GITLAB_TOKEN" ] && test -e .git && ! glab repo view '{{.GITLAB_PATH}}' > /dev/null; then
            glab repo create '{{.GITLAB_PATH}}' --group '{{.GITLAB_GROUP}}' --description 'ðŸ”¥ðŸ‘‰ {{.DESCRIPTION}} ðŸš€' --name '{{.NAME}}' \
              {{.PROJECT_TYPE}} --tag '$KEYWORDS'
          else
            true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab repository cannot be created.'
          fi
        ignore_error: true
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.NAME}}" != "null" ]'
        msg: The `.blueprint.name` variable in `package.json` must be set.

  gitlab:integrations:
    deps:
      - gitlab:integrations:github

  gitlab:integrations:github:
    deps:
      - :install:software:glab
      - :install:software:jq
    env:
      GITHUB_REPO:
        sh: jq -r '.blueprint.repository.github' package.json
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ] && [ ! -z "$GITHUB_TOKEN" ]; then
          glab api projects/:fullpath/integrations/github -X PUT -f token="$GITHUB_TOKEN" -f repository_url="$GITHUB_REPO" --silent
        fi

  gitlab:mirror:
    deps:
      - :install:software:glab
      - :install:software:jq
      - github:create
      - gitlab:create
    vars:
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      GITLAB_REPO_ID:
        sh: glab api projects/:fullpath | jq -r '.id'
      PUSH_MIRROR_COUNT:
        sh: glab api projects/:fullpath/remote_mirrors | jq '. | length'
    cmds:
      - >
        if [ ! -z "$GITLAB_TOKEN" ] && [ ! -z "$GITHUB_TOKEN" ]; then
          if [[ "{{.PUSH_MIRROR_COUNT}}" == '0' ]]; then
            glab api projects/:fullpath/remote_mirrors --method POST --header "Content-Type: application/json" \
              -f "url=https://{{.GITHUB_USER}}:$GITHUB_TOKEN@github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}.git" \
              -f 'enabled=true'
          fi
          curl -s -H 'Content-Type: application/json' -H "Authorization: Bearer $GITLAB_TOKEN" -X PUT --data \
            "{\"mirror\": true, \"import_url\": \"https://{{.GITHUB_USER}}:$GITHUB_TOKEN@github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}.git\"}" \
            'https://gitlab.com/api/v4/projects/{{.GITLAB_REPO_ID}}' > /dev/null
        fi
    sources:
      - package.json

  gitlab:pipelines:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      GITLAB_REPO_ID:
        sh: glab api projects/:fullpath | jq -r '.id'
      PIPELINE_COUNT:
        sh: jq -r '.gitlab_pipelines | length' .variables.json
    env:
      PIPELINES:
        sh: jq -r '.gitlab_pipelines' .variables.json
      PIPELINE_RES:
        sh: glab api projects/:fullpath/pipeline_schedules
    cmds:
      - >
        if [ ! -z "$GITLAB_TOKEN" ]; then
          for INDEX in {1..{{.PIPELINE_COUNT}}}; do
            PIPELINE_INDEX="$((INDEX - 1))"
            ACTIVE="$(echo "$PIPELINES" | jq -r --arg i "$PIPELINE_INDEX" '.[$i | tonumber].active')"
            CRON="$(echo "$PIPELINES" | jq -r --arg i "$PIPELINE_INDEX" '.[$i | tonumber].cron' | sed 's/"//g')"
            DESC="$(echo "$PIPELINES" | jq -r --arg i "$PIPELINE_INDEX" '.[$i | tonumber].description')"
            REF="$(echo "$PIPELINES" | jq -r --arg i "$PIPELINE_INDEX" '.[$i | tonumber].ref')"
            if (! echo "$PIPELINE_RES" | grep "$DESC") > /dev/null; then
              glab api projects/:fullpath/pipeline_schedules -X POST -f active="$ACTIVE" -f description="$DESC" -f ref="$REF" \
                -f cron="$CRON" -f cron_timezone='{{.TIMEZONE}}' --silent
              true success 'Pipeline with description of `$DESC` successfully added'
            else
              true log 'Pipeline with description of `'"$DESC"'` already added'
            fi
          done
        else
          true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab pipelines cannot be updated via the API.'
        fi
    sources:
      - .variables.json
      - package.json

  gitlab:pipelines:clear:
    env:
      TMP:
        sh: mktemp
    cmds:
      - |
        glab api projects/:id/pipeline_schedules -X GET > "$TMP"
        for PIPELINE_ID in $(jq -r '.[].id' "$TMP"); do
          glab api projects/:fullpath/pipeline_schedules/"$PIPELINE_ID" -X DELETE
        done
    preconditions:
      - sh: '[ ! -z "$GITLAB_TOKEN" ]'
        msg: The `GITLAB_TOKEN` environment variable must be set to run this task

  gitlab:update:
    deps:
      - gitlab:mirror
      - gitlab:integrations
      - gitlab:pipelines
      - gitlab:update:meta
      - gitlab:wiki

  gitlab:update:meta:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      ISSUES_TEMPLATE: '## Summary\r\n\r\n(Summarize the bug encountered concisely)\r\n\r\n##
        Steps to reproduce\r\n\r\n(How one can reproduce the issue - this is very important)\r\n\r\n##
        Example Project\r\n\r\n(If possible, please create an example project here on GitLab.com that
        exhibits the problematic\r\nbehavior, and link to it here in the bug report.\r\nIf you are using
        an older version of GitLab, this will also determine whether the bug has been fixed\r\nin a more
        recent version)\r\n\r\n## What is the current bug behavior?\r\n\r\n(What actually happens)\r\n\r\n##
        What is the expected correct behavior?\r\n\r\n(What you should see instead)\r\n\r\n## Relevant
        logs and/or screenshots\r\n\r\n(Paste any relevant logs - please use code blocks (```) to format
        console output, logs, and code, as\r\nit is very hard to read otherwise.)\r\n\r\n## Possible
        fixes\r\n\r\n(If you can, link to the line of code that might be responsible for the problem)'
      NAME:
        sh: jq -r '.blueprint.name' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo 'private'; else echo 'public'; fi
      TEST_COVERAGE_REGEX:
        sh: jq -r '.build_coverage_regex' .variables.json | sed 's/^null$//'
    env:
      KEYWORDS:
        sh: jq -r '.keywords | tostring' package.json | sed 's/\[//' | sed 's/\]//' | sed 's/"//g'
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          PROJECT_ID="$(glab api projects/:fullpath -X PUT -f build_coverage_regex="{{.TEST_COVERAGE_REGEX}}" \
          -f wiki_enabled={{.GITLAB_WIKI}} -f visibility="{{.PROJECT_TYPE}}" -f topics="$KEYWORDS" | jq '.id')"
          curl -s -H 'Content-Type: application/json' -H "Authorization: Bearer $GITLAB_TOKEN" -X PUT --data \
          '{"description": "ðŸ”¥ðŸ‘‰ {{.DESCRIPTION}} ðŸš€", "issues_template": "{{.ISSUES_TEMPLATE}}", "name": "{{.NAME}}"}' \
          "https://gitlab.com/api/v4/projects/$PROJECT_ID" > /dev/null
        else
          true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab repository cannot be updated via the API.'
        fi
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.NAME}}" != "null" ]'
        msg: The `.blueprint.name` variable in `package.json` must be set.

  gitlab:wiki:
    deps:
      - :common:update:variables
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      DOCS_URL:
        sh: jq -r '.docs.link' .variables.json
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          glab api projects/:fullpath/services/external-wiki -X PUT -f external_wiki_url="{{.DOCS_URL}}" --silent
        else
          true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab repository external wiki cannot be updated via the API.'
        fi
    sources:
      - .variables.json
    preconditions:
      - sh: '[ "{{.DOCS_URL}}" != "null" ]'
        msg: The `.docs.link` variable in `.variables.json` must be set.
      - sh: '[ "{{.GROUP}}" != "null" ]'
        msg: The `.group` variable in `.variables.json` must be set.

  remotes:
    deps:
      - :install:software:git
      - :install:software:jq
    desc: Configure the git remote `origin` to point to GitLab and the git remote `all` to point to GitLab and GitHub
    summary: |
      # Configure git remote

      This task will set the origin to the GitLab repository associated with this project. It will then also create
      a remote named `all` which will point to both the GitLab repository and the GitHub mirror. You can then
      push to both repositories at the same time by running `git push origin master`.

      **Example usage:**
      `task git:remotes`
    env:
      GITHUB_REPO:
        sh: jq -r '.blueprint.repository.github' package.json | sed 's/^https:\/\//git@/' | sed 's/github.com\//github.com:/'
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/^https:\/\//git@/' | sed 's/gitlab.com\//gitlab.com:/'
    cmds:
      - |
        if [ ! -z "$GITLAB_REPO" ]; then
          if git config remote.origin.url > /dev/null; then
            git remote set-url origin "${GITLAB_REPO}.git"
          else
            git remote add origin "${GITLAB_REPO}.git"
          fi
          if git config remote.gitlab.url > /dev/null; then
            git remote set-url gitlab "${GITLAB_REPO}.git"
          else
            git remote add gitlab "${GITLAB_REPO}.git"
          fi
        fi
      - |
        if [ ! -z "$GITHUB_REPO" ]; then
          if git config remote.github.url > /dev/null; then
            git remote set-url github "${GITHUB_REPO}.git"
          else
            git remote add github "${GITHUB_REPO}.git"
          fi
        fi
      - |
        if [ ! -z "$GITLAB_REPO" ] && [ ! -z "$GITHUB_REPO" ]; then
          if git config remote.all.url > /dev/null; then
            git remote rm all
          fi
          git remote add all "${GITLAB_REPO}.git"
          git remote set-url --add --push all "${GITHUB_REPO}.git"
          git remote set-url --add --push all "${GITLAB_REPO}.git"
        fi
    status:
      - '[[ "$(git config remote.all.url)" == "${GITLAB_REPO}.git" ]] || [[ "${container:=}" == "docker" ]]'
      - '[[ "$(git config remote.github.url)" == "${GITHUB_REPO}.git" ]] || [[ "${container:=}" == "docker" ]]'
      - '[[ "$(git config remote.gitlab.url)" == "${GITLAB_REPO}.git" ]] || [[ "${container:=}" == "docker" ]]'

  remove:submodules:
    deps:
      - :install:software:git
    desc: Remove all submodules in the current directory and optionally filter by RegEx
    summary: |
      # Remove submodules in current directory

      This task will remove all the submodules in the current directory and its' children.
      You can optionally specify RegEx to only remove submodules that match a particular pattern.
      Please note that this task is not _perfect_. You should commit your current changes before using it
      and then reset the repository with `git reset --hard HEAD` if anything pops up on `git status` that
      you do not like after running it.

      **Example removing all submodules that are children of the working directory:**
      `task git:remove-submodules`

      **Example removing all submodules that are children of the working directory and matching a pattern:**
      `task git:remove-submodules -- docs`
    vars:
      GITMODULES_PATH: .gitmodules
      REGEX_ARG:
        sh: if [ -z "{{.CLI_ARGS}}" ]; then echo ""; else echo " | grep {{.CLI_ARGS}}"; fi
      RELATIVE_PATH:
        sh: pwd | sed "s,^$(git rev-parse --show-toplevel),," | cut -c2-
      # /home/hawkwood/Downloads/Backup/Code
      ROOT_GIT:
        sh: git rev-parse --git-dir | sed 's/\.git\/modules\(.*\)/.gitmodules/' | sed 's/\.git$/.gitmodules/' | sed 's/.gitmodules$//'
      # /home/hawkwood/Downloads/Backup/Code/docker/ci-pipeline/hadolint
      TOP_LEVEL:
        sh: git rev-parse --show-toplevel
    cmds:
      - |
        if [ -f '.gitmodules' ]; then
          MODULE_PATHS=$(git config --file "{{.GITMODULES_PATH}}" --name-only --get-regexp "{{.RELATIVE_PATH}}" |
            sed 's/^submodule\.//' | grep "path$" | sed 's/\.path$//'{{.REGEX_ARG}})
          for MODULE_PATH in "$MODULE_PATHS"; do
            # https://github.com/a14m/gitsubmodule/blob/master/gitsubmodule
            git config -f '{{.GITMODULES_PATH}}' --remove-section "submodule.$MODULE_PATH" | true
            git add '{{.GITMODULES_PATH}}'
            # /home/hawkwood/Downloads/Backup/Code/.git/modules/docker/ci-pipeline/hadolint/config
            {{if .ROOT_GIT}}
              CONFIG_PATH="$(pwd | sed 's,{{.ROOT_GIT}},,')"
            {{else}}
              CONFIG_PATH='.git'
            {{end}}
            git config -f '{{.ROOT_GIT}}./{{if ne .ROOT_GIT ""}}.git/modules/{{end}}'"$CONFIG_PATH"'/config' --remove-section "submodule.$MODULE_PATH"
            git rm --cached "$MODULE_PATH"
            rm -rf "{{.ROOT_GIT}}./.git/modules/$CONFIG_PATH"
            rm -rf "$MODULE_PATH"
          done
        else
          true info 'This task does not run unless there is a `.gitmodules` file in the current directory'
        fi
